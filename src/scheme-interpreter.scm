(load "./definitions.scm")

; Обработка ошибок через сохранение состояния

(define stop 0)

(define (exit)
  (call-with-current-continuation
   (lambda (c)
     (set! stop c))))

(exit)

; ws - вектор слов
; wc - счетчик слов (индекс текущего слова)
; xs - стек данных
; rs - стек возвратов
; as - словарь статей
; vs - словарь переменных 

(define (interpret program stack)
  (define (inter ws wc xs rs as vs)
    (if (>= wc (vector-length ws))
        xs
        (begin
          (let ((token (vector-ref ws wc)))
            (or
             (and (assoc token as)
                  (inter ws (cdr (assoc token as)) xs (cons (+ wc 1) rs) as vs))             
             (and (assoc token vs)
                  (inter ws (+ wc 1) (if (number? (cdr (assoc token vs)))
                                         (cons (cdr (assoc token vs)) xs)
                                         (begin
                                           (display "Syntaxis error:")
                                           (newline)
                                           (display (cdr (assoc token vs)))
                                           (display " undefined ")
                                           (stop)
                                           ))
                         rs as vs))
             (and (number? token)
                  (inter ws (+ wc 1) (cons token xs) rs as vs))
             (and (+? token)
                  (inter ws (+ wc 1) (last2 + xs) rs as vs))
             (and (-? token)
                  (inter ws (+ wc 1) (last2 - xs) rs as vs))
             (and (*? token)
                  (inter ws (+ wc 1) (last2 * xs) rs as vs))
             (and (/? token)
                  (inter ws (+ wc 1) (last2 quotient xs) rs as vs))
             (and (mod? token)
                  (inter ws (+ wc 1) (last2 remainder xs) rs as vs))
             (and (neg? token)
                  (inter ws (+ wc 1) (neg xs) rs as vs))
             (and (=? token)
                  (inter ws (+ wc 1) (bool-2 = xs) rs as vs))
             (and (>? token)
                  (inter ws (+ wc 1) (bool-2 > xs) rs as vs))
             (and (<? token)
                  (inter ws (+ wc 1) (bool-2 < xs) rs as vs))
             (and (not? token)
                  (inter ws (+ wc 1) (lp not xs) rs as vs))
             (and (and? token)
                  (inter ws (+ wc 1) (lp and xs) rs as vs))
             (and (or? token)
                  (inter ws (+ wc 1) (lp or xs) rs as vs))
             (and (drop? token)
                  (inter ws (+ wc 1) (cdr xs) rs as vs))
             (and (swap? token)
                  (inter ws (+ wc 1) (swap xs) rs as vs))
             (and (dup? token)
                  (inter ws (+ wc 1) (dup xs) rs as vs))
             (and (over? token)
                  (inter ws (+ wc 1) (over xs) rs as vs))
             (and (rot? token)
                  (inter ws (+ wc 1) (rot xs) rs as vs))
             (and (depth? token)
                  (inter ws (+ wc 1) (depth xs) rs as vs))
             (and (define? token)
                  (inter ws (find-num+1 'end ws wc) xs rs (cons (cons (vector-ref ws (+ wc 1)) (+ wc 2)) as) vs))
             (and (end? token)
                  (inter ws (car rs) xs (cdr rs) as vs))
             (and (exit? token)
                  (inter ws (car rs) xs (cdr rs) as vs))
             
             (and (if? token)
                  (inter ws (or (and (equal? (car xs) 0) (or (and (and (find-num+1 'else ws wc)
                                                                       (< (find-num+1 'else ws wc) (find-num+1 'endif ws wc)))
                                                                  (find-num+1 'else ws wc))
                                                             (find-num+1 'endif ws wc)))
                                (+ wc 1))
                         (cdr xs) rs as vs))
             (and (endif? token)
                  (inter ws (+ wc 1) xs rs as vs))
             (and (else? token)
                  (inter ws (find-num+1 'endif ws wc) xs rs as vs))
             (and (clear? token)
                  (inter ws (+ wc 2) xs rs (clear (vector-ref ws (+ wc 1)) as) vs))
             (and (variable? token)
                  (inter ws (+ wc 2) (cdr xs) rs as (cons (cons (vector-ref ws (+ wc 1)) (car xs)) vs)))
             (and (set? token)
                  (inter ws (+ wc 2) (cdr xs) rs as (cons (cons (vector-ref ws (+ wc 1))
                                                                (car xs))
                                                          (clear (vector-ref ws (+ wc 1)) vs))))
             
             (begin
               (display "Syntaxis Error: in ")
               (write token)
               (display "\nUnknown constuction!")))))))
  (inter program 0 stack '() '() '()))
